#!/usr/bin/env bash

set -e

# ECR Mirror CLI Tool
# Manage ECR image mirroring from public registries

VERSION="1.0.0"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
AWS_REGION="${AWS_DEFAULT_REGION:-us-west-2}"
AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-}"
ECR_REGISTRY=""

# Usage information
usage() {
    cat << EOF
ECR Mirror CLI Tool v${VERSION}

Usage: ecr-mirror [command] [options]

Commands:
    list                    List all ECR repositories and their images
    search <term>          Search ECR by repository, image, or tag
    mirror <file>          Mirror images from file to ECR
    version                Show version
    help                   Show this help message

Options:
    --region <region>      AWS region (default: $AWS_REGION)
    --account <id>         AWS account ID (required for mirror)
    --dry-run              Show what would be done without doing it

Examples:
    # List all ECR images
    ecr-mirror list

    # Search for images
    ecr-mirror search nginx
    ecr-mirror search v3.5.0
    ecr-mirror search kubernetes-csi

    # Mirror images from file
    ecr-mirror mirror images.txt --account 123456789012

    # Mirror with specific region
    ecr-mirror mirror images.txt --account 123456789012 --region us-west-2

    # Dry run to see what would happen
    ecr-mirror mirror images.txt --account 123456789012 --dry-run

Environment Variables:
    AWS_DEFAULT_REGION     Default AWS region
    AWS_ACCOUNT_ID         AWS account ID
    AWS_ACCESS_KEY_ID      AWS access key
    AWS_SECRET_ACCESS_KEY  AWS secret key

EOF
}

# Print colored output
print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1" >&2
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

# Check dependencies
check_dependencies() {
    local missing=0
    
    if ! command -v aws &> /dev/null; then
        print_error "AWS CLI is not installed"
        missing=1
    fi
    
    if ! command -v skopeo &> /dev/null; then
        print_error "Skopeo is not installed"
        missing=1
    fi
    
    if [ $missing -eq 1 ]; then
        echo ""
        echo "Please install missing dependencies:"
        echo "  AWS CLI: https://aws.amazon.com/cli/"
        echo "  Skopeo: https://github.com/containers/skopeo"
        exit 1
    fi
}

# Verify AWS credentials
verify_aws_credentials() {
    print_info "Verifying AWS credentials..."
    
    if ! aws sts get-caller-identity &> /dev/null; then
        print_error "AWS credentials are not configured"
        echo ""
        echo "Please configure AWS credentials:"
        echo "  export AWS_ACCESS_KEY_ID=your_key"
        echo "  export AWS_SECRET_ACCESS_KEY=your_secret"
        echo "Or run: aws configure"
        exit 1
    fi
    
    local identity=$(aws sts get-caller-identity --output json)
    local account=$(echo "$identity" | grep -o '"Account": "[^"]*"' | cut -d'"' -f4)
    local user=$(echo "$identity" | grep -o '"Arn": "[^"]*"' | cut -d'"' -f4)
    
    print_success "Authenticated as: $user"
    print_info "Account: $account"
    
    # Set account ID if not provided
    if [ -z "$AWS_ACCOUNT_ID" ]; then
        AWS_ACCOUNT_ID="$account"
    fi
}

# List all ECR repositories and images
list_ecr_images() {
    print_info "Fetching ECR repositories in region: $AWS_REGION"
    echo ""
    
    # Check if jq is available for better JSON parsing
    local has_jq=false
    if command -v jq &> /dev/null; then
        has_jq=true
    fi
    
    # Get all repositories
    if [ "$has_jq" = true ]; then
        # Use jq for clean parsing
        local repo_names=$(aws ecr describe-repositories \
            --region "$AWS_REGION" \
            --output json 2>/dev/null | jq -r '.repositories[].repositoryName' 2>/dev/null)
    else
        # Fallback to text output
        local repo_names=$(aws ecr describe-repositories \
            --region "$AWS_REGION" \
            --output text \
            --query 'repositories[].repositoryName' 2>/dev/null)
    fi
    
    if [ -z "$repo_names" ]; then
        print_warning "No ECR repositories found"
        return
    fi
    
    local repo_count=$(echo "$repo_names" | wc -l | tr -d ' ')
    print_success "Found $repo_count repositories"
    echo ""
    
    # Iterate through each repository
    while IFS= read -r repo_name; do
        [ -z "$repo_name" ] && continue
        
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Repository: $repo_name"
        
        # Get repository URI
        if [ "$has_jq" = true ]; then
            local repo_uri=$(aws ecr describe-repositories \
                --repository-names "$repo_name" \
                --region "$AWS_REGION" \
                --output json 2>/dev/null | jq -r '.repositories[0].repositoryUri' 2>/dev/null)
        else
            local repo_uri=$(aws ecr describe-repositories \
                --repository-names "$repo_name" \
                --region "$AWS_REGION" \
                --output text \
                --query 'repositories[0].repositoryUri' 2>/dev/null)
        fi
        echo "URI: $repo_uri"
        
        # Get images/tags for this repository
        if [ "$has_jq" = true ]; then
            # Use jq to get tags
            local tags=$(aws ecr describe-images \
                --repository-name "$repo_name" \
                --region "$AWS_REGION" \
                --output json 2>/dev/null | jq -r '.imageDetails[].imageTags[]?' 2>/dev/null | sort -V)
        else
            # Use text output to get tags
            local tags=$(aws ecr describe-images \
                --repository-name "$repo_name" \
                --region "$AWS_REGION" \
                --output text \
                --query 'imageDetails[].imageTags[]' 2>/dev/null | tr '\t' '\n' | sort -V)
        fi
        
        if [ -z "$tags" ]; then
            echo "Tags: (no tagged images)"
        else
            local tag_count=$(echo "$tags" | wc -l | tr -d ' ')
            echo "Images: $tag_count tagged"
            echo ""
            echo "Tags:"
            
            # Display tags in cyan for visibility on dark terminals
            while IFS= read -r tag; do
                [ -z "$tag" ] && continue
                echo -e "  ${CYAN}•${NC} $tag"
            done <<< "$tags"
        fi
        
        echo ""
    done <<< "$repo_names"
}

# Search ECR repositories and images
search_ecr() {
    local search_term="$1"
    
    if [ -z "$search_term" ]; then
        print_error "Search term is required"
        echo "Usage: ecr-mirror search <term>"
        exit 1
    fi
    
    print_info "Searching ECR for: '$search_term'"
    print_info "Region: $AWS_REGION"
    echo ""
    
    # Check if jq is available
    local has_jq=false
    if command -v jq &> /dev/null; then
        has_jq=true
    fi
    
    # Get all repositories
    if [ "$has_jq" = true ]; then
        local repo_names=$(aws ecr describe-repositories \
            --region "$AWS_REGION" \
            --output json 2>/dev/null | jq -r '.repositories[].repositoryName' 2>/dev/null)
    else
        local repo_names=$(aws ecr describe-repositories \
            --region "$AWS_REGION" \
            --output text \
            --query 'repositories[].repositoryName' 2>/dev/null)
    fi
    
    if [ -z "$repo_names" ]; then
        print_warning "No ECR repositories found"
        return
    fi
    
    local match_count=0
    local repo_match_count=0
    local tag_match_count=0
    
    # Search through repositories
    while IFS= read -r repo_name; do
        [ -z "$repo_name" ] && continue
        
        local repo_matches=false
        local matching_tags=""
        
        # Check if repository name matches
        if echo "$repo_name" | grep -qi "$search_term"; then
            repo_matches=true
            repo_match_count=$((repo_match_count + 1))
        fi
        
        # Get tags for this repository
        if [ "$has_jq" = true ]; then
            local tags=$(aws ecr describe-images \
                --repository-name "$repo_name" \
                --region "$AWS_REGION" \
                --output json 2>/dev/null | jq -r '.imageDetails[].imageTags[]?' 2>/dev/null)
        else
            local tags=$(aws ecr describe-images \
                --repository-name "$repo_name" \
                --region "$AWS_REGION" \
                --output text \
                --query 'imageDetails[].imageTags[]' 2>/dev/null | tr '\t' '\n')
        fi
        
        # Check if any tags match
        if [ -n "$tags" ]; then
            matching_tags=$(echo "$tags" | grep -i "$search_term" || true)
        fi
        
        # If repository or tags match, display results
        if [ "$repo_matches" = true ] || [ -n "$matching_tags" ]; then
            match_count=$((match_count + 1))
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            
            # Highlight repository name if it matches
            if [ "$repo_matches" = true ]; then
                echo -e "Repository: ${GREEN}$repo_name${NC} ${YELLOW}[MATCH]${NC}"
            else
                echo "Repository: $repo_name"
            fi
            
            # Get repository URI
            if [ "$has_jq" = true ]; then
                local repo_uri=$(aws ecr describe-repositories \
                    --repository-names "$repo_name" \
                    --region "$AWS_REGION" \
                    --output json 2>/dev/null | jq -r '.repositories[0].repositoryUri' 2>/dev/null)
            else
                local repo_uri=$(aws ecr describe-repositories \
                    --repository-names "$repo_name" \
                    --region "$AWS_REGION" \
                    --output text \
                    --query 'repositories[0].repositoryUri' 2>/dev/null)
            fi
            echo "URI: $repo_uri"
            
            # Display tags
            if [ -n "$matching_tags" ]; then
                local match_tag_count=$(echo "$matching_tags" | wc -l | tr -d ' ')
                tag_match_count=$((tag_match_count + match_tag_count))
                echo ""
                echo "Matching Tags: ($match_tag_count)"
                
                while IFS= read -r tag; do
                    [ -z "$tag" ] && continue
                    echo -e "  ${CYAN}•${NC} ${GREEN}$tag${NC}"
                done <<< "$matching_tags"
            elif [ "$repo_matches" = true ]; then
                # Repository matches but no tag matches, show all tags
                if [ -n "$tags" ]; then
                    local all_tag_count=$(echo "$tags" | wc -l | tr -d ' ')
                    echo ""
                    echo "All Tags: ($all_tag_count)"
                    
                    echo "$tags" | sort -V | while IFS= read -r tag; do
                        [ -z "$tag" ] && continue
                        echo -e "  ${CYAN}•${NC} $tag"
                    done
                else
                    echo ""
                    echo "Tags: (no tagged images)"
                fi
            fi
            
            echo ""
        fi
        
    done <<< "$repo_names"
    
    # Summary
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "SEARCH RESULTS"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Search term: '$search_term'"
    echo "Repositories matched: $repo_match_count"
    echo "Tags matched: $tag_match_count"
    echo "Total matches: $match_count"
    echo ""
    
    if [ $match_count -eq 0 ]; then
        print_warning "No matches found for '$search_term'"
    else
        print_success "Found $match_count matching repositories/images"
    fi
}

# Parse image string to extract components
parse_image() {
    local image_tag="$1"
    
    # Extract everything before the last ':'
    PUBLIC_IMAGE=$(echo "$image_tag" | sed 's/:[^:]*$//')
    
    # Extract everything after the last ':'
    IMAGE_TAG=$(echo "$image_tag" | sed 's/.*://')
    
    # Determine ECR repository name
    if echo "$PUBLIC_IMAGE" | grep -q '/'; then
        if echo "$PUBLIC_IMAGE" | grep -qE '^[a-z0-9.-]+\.[a-z]{2,}(/|:)'; then
            PATH_PART=$(echo "$PUBLIC_IMAGE" | sed -E 's|^[a-z0-9.-]+\.[a-z]{2,}[:/]||')
        else
            PATH_PART="$PUBLIC_IMAGE"
        fi
        REPO_NAME=$(echo "$PATH_PART" | tr '/' '-')
    else
        REPO_NAME="$PUBLIC_IMAGE"
    fi
}

# Create ECR repository if it doesn't exist
create_ecr_repo() {
    local repo_name="$1"
    local dry_run="$2"
    
    # Check if repository exists
    if aws ecr describe-repositories \
        --repository-names "$repo_name" \
        --region "$AWS_REGION" &> /dev/null; then
        print_info "Repository exists: $repo_name"
        return 0
    fi
    
    if [ "$dry_run" = "true" ]; then
        print_warning "[DRY-RUN] Would create repository: $repo_name"
        return 0
    fi
    
    print_info "Creating repository: $repo_name"
    
    aws ecr create-repository \
        --repository-name "$repo_name" \
        --region "$AWS_REGION" \
        --image-scanning-configuration scanOnPush=true \
        --encryption-configuration encryptionType=AES256 \
        --tags Key=ManagedBy,Value=ecr-mirror Key=Source,Value=PublicImage \
        > /dev/null
    
    # Set lifecycle policy
    aws ecr put-lifecycle-policy \
        --repository-name "$repo_name" \
        --region "$AWS_REGION" \
        --lifecycle-policy-text '{
          "rules": [{
            "rulePriority": 1,
            "description": "Keep last 10 images",
            "selection": {
              "tagStatus": "any",
              "countType": "imageCountMoreThan",
              "countNumber": 10
            },
            "action": { "type": "expire" }
          }]
        }' > /dev/null
    
    print_success "Created repository: $repo_name"
}

# Mirror a single image
mirror_image() {
    local image_tag="$1"
    local dry_run="$2"
    local ecr_password="$3"
    
    # Parse image
    parse_image "$image_tag"
    
    local ecr_repo="$ECR_REGISTRY/$REPO_NAME"
    
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print_info "Processing: $image_tag"
    echo ""
    echo "  Source Image: $PUBLIC_IMAGE:$IMAGE_TAG"
    echo "  ECR Repository: $REPO_NAME"
    echo "  Destination: $ecr_repo:$IMAGE_TAG"
    echo ""
    
    # Create repository if needed
    create_ecr_repo "$REPO_NAME" "$dry_run"
    
    # Check if image already exists in ECR
    if aws ecr describe-images \
        --repository-name "$REPO_NAME" \
        --image-ids imageTag="$IMAGE_TAG" \
        --region "$AWS_REGION" &> /dev/null; then
        print_warning "Image already exists in ECR, skipping"
        return 0
    fi
    
    # Determine source format
    if echo "$PUBLIC_IMAGE" | grep -qE '^[a-z0-9.-]+\.[a-z]{2,}/'; then
        SOURCE_IMAGE="docker://$PUBLIC_IMAGE:$IMAGE_TAG"
    else
        SOURCE_IMAGE="docker://docker.io/$PUBLIC_IMAGE:$IMAGE_TAG"
    fi
    
    local dest_image="docker://$ecr_repo:$IMAGE_TAG"
    
    if [ "$dry_run" = "true" ]; then
        print_warning "[DRY-RUN] Would copy:"
        echo "  From: $SOURCE_IMAGE"
        echo "  To:   $dest_image"
        return 0
    fi
    
    print_info "Copying image with skopeo..."
    echo "  From: $SOURCE_IMAGE"
    echo "  To:   $dest_image"
    echo ""
    
    # Copy with skopeo
    if skopeo copy \
        --src-no-creds \
        --dest-creds "AWS:$ecr_password" \
        --override-os linux \
        --override-arch amd64 \
        --retry-times 3 \
        "$SOURCE_IMAGE" \
        "$dest_image"; then
        
        print_success "Successfully mirrored: $image_tag"
        return 0
    else
        print_error "Failed to mirror: $image_tag"
        return 1
    fi
}

# Mirror images from file
mirror_from_file() {
    local file="$1"
    local dry_run="$2"
    
    if [ ! -f "$file" ]; then
        print_error "File not found: $file"
        exit 1
    fi
    
    if [ -z "$AWS_ACCOUNT_ID" ]; then
        print_error "AWS account ID is required"
        echo "Provide via --account option or AWS_ACCOUNT_ID environment variable"
        exit 1
    fi
    
    ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
    
    print_info "ECR Registry: $ECR_REGISTRY"
    print_info "Region: $AWS_REGION"
    
    if [ "$dry_run" = "true" ]; then
        print_warning "DRY-RUN MODE: No changes will be made"
    fi
    
    echo ""
    
    # Get ECR credentials
    local ecr_password=""
    if [ "$dry_run" != "true" ]; then
        print_info "Getting ECR credentials..."
        ecr_password=$(aws ecr get-login-password --region "$AWS_REGION")
        print_success "ECR credentials obtained"
    fi
    
    # Read images from file
    local success_count=0
    local fail_count=0
    local skip_count=0
    
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^#.*$ ]] && continue
        [[ -z "$line" ]] && continue
        
        # Validate format
        if ! echo "$line" | grep -qE '^[a-zA-Z0-9/_.-]+:[a-zA-Z0-9_.-]+$'; then
            print_warning "Invalid format, skipping: $line"
            skip_count=$((skip_count + 1))
            continue
        fi
        
        if mirror_image "$line" "$dry_run" "$ecr_password"; then
            success_count=$((success_count + 1))
        else
            fail_count=$((fail_count + 1))
        fi
        
    done < "$file"
    
    # Summary
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "SUMMARY"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "  Successful: $success_count"
    echo "  Failed: $fail_count"
    echo "  Skipped: $skip_count"
    echo ""
    
    if [ $fail_count -gt 0 ]; then
        print_error "Some images failed to mirror"
        exit 1
    else
        print_success "All images mirrored successfully!"
    fi
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        usage
        exit 0
    fi
    
    local command="$1"
    shift
    
    # Parse global options
    local dry_run="false"
    
    while [ $# -gt 0 ]; do
        case "$1" in
            --region)
                AWS_REGION="$2"
                shift 2
                ;;
            --account)
                AWS_ACCOUNT_ID="$2"
                shift 2
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    
    case "$command" in
        list)
            check_dependencies
            verify_aws_credentials
            list_ecr_images
            ;;
        search)
            if [ $# -eq 0 ]; then
                print_error "Missing search term"
                echo "Usage: ecr-mirror search <term>"
                exit 1
            fi
            check_dependencies
            verify_aws_credentials
            search_ecr "$1"
            ;;
        mirror)
            if [ $# -eq 0 ]; then
                print_error "Missing file argument"
                echo "Usage: ecr-mirror mirror <file>"
                exit 1
            fi
            check_dependencies
            verify_aws_credentials
            mirror_from_file "$1" "$dry_run"
            ;;
        version)
            echo "ecr-mirror version $VERSION"
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            print_error "Unknown command: $command"
            echo ""
            usage
            exit 1
            ;;
    esac
}

main "$@"
